name: Atualizar PR (Formulário GMUD)

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, reopened, synchronize, edited]

permissions:
  contents: write
  pull-requests: write

jobs:
  atualizar-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      # Verifica se o evento é "edited"
      - name: Verificar se é edição do corpo do PR
        id: check_event
        run: |
          echo "action=${{ github.event.action }}"
          if [ "${{ github.event.action }}" = "edited" ]; then
            echo "::set-output name=edited::true"
          else
            echo "::set-output name=edited::false"
          fi

      # Checa alterações de migrations somente se NÃO for "edited"
      - name: Verificar alterações de migrations
        id: check_migrations
        if: steps.check_event.outputs.edited == 'false'
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          if echo "$CHANGED_FILES" | grep -q '^application/migrations/'; then
            echo "::set-output name=has_migrations::true"
          else
            echo "::set-output name=has_migrations::false"
          fi

      # Atualiza o placeholder no corpo do PR (exceto em edição manual)
      - name: Atualizar corpo do PR (Formulário GMUD)
        if: steps.check_event.outputs.edited == 'false'
        uses: actions/github-script@v6
        env:
          MIGRATIONS: ${{ steps.check_migrations.outputs.has_migrations }}
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            let currentBody = context.payload.pull_request.body || "";

            const now = new Date();
            const nowFormatted = now.toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });

            const migrationText = `**${process.env.MIGRATIONS === 'true' ? 'SIM' : 'NÃO'}** - ${nowFormatted}`;
            if (currentBody.includes("<!-- MIGRATIONS_PLACEHOLDER -->")) {
              currentBody = currentBody.replace("<!-- MIGRATIONS_PLACEHOLDER -->", migrationText);
            } else {
              currentBody += "\n\n" + migrationText;
            }

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull_number,
              body: currentBody
            });

      # Aplica labels (rodando sempre, mesmo em edição)
      - name: Aplicar labels
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || "";
            const edited = context.payload.action === "edited";

            // Se não for 'edited', usamos a saída do step check_migrations
            let hasMigrations = false;
            if (!edited) {
              hasMigrations = '${{ steps.check_migrations.outputs.has_migrations }}' === 'true';
            }

            let labelsToAdd = [];

            // Se houver migrations, adiciona label "Migration"
            if (hasMigrations) {
              labelsToAdd.push("Migration");
            }

            // Se o campo "Essa mudança pode quebrar o sistema?" estiver marcado como Sim
            const breakRegex = /\*\*1\. Essa mudança pode quebrar o sistema\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (breakRegex.test(prBody)) {
              labelsToAdd.push("Breaking Changes");
            }

            // Se a prioridade for "Crítica"
            const criticRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Crítica/;
            if (criticRegex.test(prBody)) {
              labelsToAdd.push("Critic");
            }

            // Se a prioridade for "Normal"
            const normalRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Normal/;
            if (normalRegex.test(prBody)) {
              labelsToAdd.push("Normal");
            }

            // Se "A mudança foi homologada por QA?" estiver marcada como Sim
            const qaRegex = /\*\*4\. A mudança foi homologada por QA\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (qaRegex.test(prBody)) {
              labelsToAdd.push("QA validated");
            }

            if (labelsToAdd.length === 0) {
              console.log("Nenhuma label para adicionar.");
              return;
            }

            const labelConfigs = {
              "Migration": "0E8A16",         // verde
              "Breaking Changes": "5319E7",  // roxo
              "Critic": "FF0000",            // vermelho
              "Normal": "1D76DB",            // azul
              "QA validated": "0E8A16"       // verde
            };

            // Para cada label, verifica se ela já existe; se não, cria; se sim, opcionalmente atualiza a cor
            for (const label of labelsToAdd) {
              let exists = false;
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label
                });
                exists = true;
              } catch (error) {
                if (error.status === 404) {
                  exists = false;
                } else {
                  throw error;
                }
              }

              if (!exists) {
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelConfigs[label]
                  });
                } catch (error) {
                  // Se o erro for 422 (já existe), ignora
                  if (error.status !== 422) {
                    throw error;
                  }
                }
              } else {
                try {
                  await github.rest.issues.updateLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    current_name: label,
                    color: labelConfigs[label]
                  });
                } catch (error) {
                  console.log(`Falha ao atualizar label ${label}: ${error.message}`);
                }
              }
            }

            // Adiciona as labels ao PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number,
              labels: labelsToAdd
            });