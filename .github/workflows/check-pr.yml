name: Atualizar PR (Formulário GMUD)

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, reopened, synchronize, edited]

permissions:
  contents: write
  pull-requests: write

jobs:
  atualizar-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      # Passo para detectar se a ação atual é "edited"
      - name: Verificar se é edição do corpo do PR
        id: check_event
        run: |
          echo "action=${{ github.event.action }}"
          if [ "${{ github.event.action }}" = "edited" ]; then
            echo "::set-output name=edited::true"
          else
            echo "::set-output name=edited::false"
          fi

      # 1) Verifica alterações de migrations (somente se NÃO for edited)
      - name: Verificar alterações de migrations
        id: check_migrations
        if: steps.check_event.outputs.edited == 'false'
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          if echo "$CHANGED_FILES" | grep -q '^application/migrations/'; then
            echo "::set-output name=has_migrations::true"
          else
            echo "::set-output name=has_migrations::false"
          fi

      # 2) Atualiza o placeholder no corpo do PR (somente se NÃO for edited)
      - name: Atualizar corpo do PR (Formulário GMUD)
        if: steps.check_event.outputs.edited == 'false'
        uses: actions/github-script@v6
        env:
          MIGRATIONS: ${{ steps.check_migrations.outputs.has_migrations }}
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            let currentBody = context.payload.pull_request.body || "";

            const now = new Date();
            const nowFormatted = now.toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });

            const migrationText = `**${process.env.MIGRATIONS === 'true' ? 'SIM' : 'NÃO'}** - ${nowFormatted}`;
            if (currentBody.includes("<!-- MIGRATIONS_PLACEHOLDER -->")) {
              currentBody = currentBody.replace("<!-- MIGRATIONS_PLACEHOLDER -->", migrationText);
            } else {
              currentBody += "\n\n" + migrationText;
            }

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull_number,
              body: currentBody
            });

      # 3) Aplica labels (roda sempre, inclusive em "edited")
      - name: Aplicar labels
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || "";
            const edited = context.payload.action === "edited";

            // Se não for 'edited', podemos ler a saída do step check_migrations
            // Se for 'edited', vamos considerar migrations = false (para não mudar nada)
            let hasMigrations = false;
            if (!edited) {
              hasMigrations = '${{ steps.check_migrations.outputs.has_migrations }}' === 'true';
            }

            let labelsToAdd = [];

            // Se tiver migrations => label "Migration" (verde)
            if (hasMigrations) {
              labelsToAdd.push("Migration");
            }

            // Se "pode quebrar" => label "Breaking Changes" (roxo)
            // Procura por '- [x] Sim' no item 1
            const breakRegex = /\*\*1\. Essa mudança pode quebrar o sistema\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (breakRegex.test(prBody)) {
              labelsToAdd.push("Breaking Changes");
            }

            // Se prioridade for "Crítica" => label "Critic" (vermelho)
            const criticRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Crítica/;
            if (criticRegex.test(prBody)) {
              labelsToAdd.push("Critic");
            }

            // Se prioridade for "Normal" => label "Normal" (azul)
            const normalRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Normal/;
            if (normalRegex.test(prBody)) {
              labelsToAdd.push("Normal");
            }

            // Se "A mudança foi homologada por QA?" => label "QA validated" (verde)
            const qaRegex = /\*\*4\. A mudança foi homologada por QA\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (qaRegex.test(prBody)) {
              labelsToAdd.push("QA validated");
            }

            if (labelsToAdd.length === 0) {
              console.log("Nenhuma label para adicionar.");
              return;
            }

            // Definir cores das labels
            const labelConfigs = {
              "Migration": "0E8A16",
              "Breaking Changes": "5319E7",
              "Critic": "FF0000",
              "Normal": "1D76DB",
              "QA validated": "0E8A16"
            };

            // 1) Verifica se cada label existe; se não existir, cria com a cor configurada
            for (const label of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label
                });
                // Se existe, atualiza a cor (caso queira garantir)
                await github.rest.issues.updateLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  current_name: label,
                  color: labelConfigs[label]
                });
              } catch (error) {
                if (error.status === 404) {
                  // Cria a label
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelConfigs[label]
                  });
                } else {
                  throw error;
                }
              }
            }

            // 2) Adiciona as labels ao PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number,
              labels: labelsToAdd
            });