name: GMUD produção

on:
  pull_request:
    branches: [ "main" ]
    types: [ opened, reopened, synchronize, edited ]

permissions:
  contents: write
  pull-requests: write

jobs:
  atualizar-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Atualizar título do PR para master
        if: github.event.pull_request.base.ref == 'main'
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const currentTitle = context.payload.pull_request.title || "";
            if (currentTitle.includes("GMUD")) {
              console.log("Título já contém GMUD, não atualizando.");
              return;
            }
            const now = new Date();
            const nowFormatted = now.toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });
            const newTitle = `Solicitação de GMUD - ${nowFormatted}`;
            console.log("Atualizando título para: " + newTitle);
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull_number,
              title: newTitle
            });

      # Detecta se o evento é "edited"
      - name: Verificar se é edição do corpo do PR
        id: check_event
        run: |
          echo "action=${{ github.event.action }}"
          if [ "${{ github.event.action }}" = "edited" ]; then
            echo "::set-output name=edited::true"
          else
            echo "::set-output name=edited::false"
          fi

      # Verifica alterações de migrations (executa somente se NÃO for "edited")
      - name: Verificar alterações de migrations
        id: check_migrations
        if: steps.check_event.outputs.edited == 'false'
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          if echo "$CHANGED_FILES" | grep -q '^application/migrations/'; then
            echo "::set-output name=has_migrations::true"
          else
            echo "::set-output name=has_migrations::false"
          fi

      # Atualiza o placeholder no corpo do PR (exceto em edição manual)
      - name: Atualizar corpo do PR (Formulário GMUD)
        if: steps.check_event.outputs.edited == 'false'
        uses: actions/github-script@v6
        env:
          MIGRATIONS: ${{ steps.check_migrations.outputs.has_migrations }}
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            let currentBody = context.payload.pull_request.body || "";
            const now = new Date();
            const nowFormatted = now.toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });
            const migrationText = `**${process.env.MIGRATIONS === 'true' ? 'SIM' : 'NÃO'}** - ${nowFormatted}`;
            if (currentBody.includes("<!-- MIGRATIONS_PLACEHOLDER -->")) {
              currentBody = currentBody.replace("<!-- MIGRATIONS_PLACEHOLDER -->", migrationText);
            } else {
              currentBody += "\n\n" + migrationText;
            }
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull_number,
              body: currentBody
            });

      # Aplica e remove labels conforme as condições do formulário
      - name: Aplicar labels do formulário
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || "";
            const edited = context.payload.action === "edited";
            // Se não for 'edited', usamos a saída do step check_migrations; se for, não atualizamos a label Migration.
            let hasMigrations = false;
            if (!edited) {
              hasMigrations = '${{ steps.check_migrations.outputs.has_migrations }}' === 'true';
            }
            let labelsToAdd = [];
            if (hasMigrations) {
              labelsToAdd.push("Migration");
            }
            // Verifica se a opção "Essa mudança pode quebrar o sistema?" está marcada como Sim
            const breakRegex = /\*\*1\. Essa mudança pode quebrar o sistema\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (breakRegex.test(prBody)) {
              labelsToAdd.push("Breaking Changes");
            }
            // Se prioridade for "Crítica"
            const criticRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Crítica/;
            if (criticRegex.test(prBody)) {
              labelsToAdd.push("Critic");
            }
            // Se prioridade for "Normal"
            const normalRegex = /\*\*3\. Classifique a prioridade dessa mudança:\*\*\s*- \[[xX]\]\s+Normal/;
            if (normalRegex.test(prBody)) {
              labelsToAdd.push("Normal");
            }
            // Se "A mudança foi homologada por QA?" estiver marcada como Sim
            const qaRegex = /\*\*4\. A mudança foi homologada por QA\?\*\*\s*- \[[xX]\]\s+Sim/;
            if (qaRegex.test(prBody)) {
              labelsToAdd.push("QA validated");
            }
            console.log("Labels para adicionar: " + JSON.stringify(labelsToAdd));
            const labelConfigs = {
              "Migration": "0E8A16",         // verde
              "Breaking Changes": "5319E7",  // roxo
              "Critic": "FF0000",            // vermelho
              "Normal": "1D76DB",            // azul
              "QA validated": "0E8A16"       // verde
            };
            // Função auxiliar para verificar e criar/atualizar label
            async function ensureLabel(label) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelConfigs[label]
                  });
                } else {
                  throw error;
                }
              }
            }
            // Cria ou atualiza as labels que devem ser aplicadas
            for (const label of labelsToAdd) {
              await ensureLabel(label);
            }
            // Adiciona as labels ao PR
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number,
              labels: labelsToAdd
            });
            } else {
              console.log("Nenhuma label para adicionar.");
            }
            // Lista as labels atualmente aplicadas no PR
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number
            });
            const currentLabelNames = currentLabels.map(l => l.name);
            // Define as labels que queremos remover se não forem mais atendidas
            const removableLabels = ["Critic", "Breaking Changes", "QA validated"];
            for (const label of removableLabels) {
              if (currentLabelNames.includes(label) && !labelsToAdd.includes(label)) {
                console.log(`Removendo label: ${label}`);
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pull_number,
                  name: label
                });
              }
            }

  fake-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      # Executa o teste fake: se houver alterações de migration, o teste é "passed"; senão, "failed"
      - name: Executar teste fake de migrations
        id: check_tests
        run: |
          git fetch origin main
          if git diff --name-only origin/main...HEAD | grep -q '^application/migrations/'; then
            echo "::set-output name=testResult::passed"
          else
            echo "::set-output name=testResult::failed"
          fi

      # Atualiza as labels de teste conforme o resultado
      - name: Atualizar labels de teste
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const testResult = '${{ steps.check_tests.outputs.testResult }}';
            console.log("Resultado do teste fake: " + testResult);
            const labelConfigs = {
              "Tests Passed": "0E8A16", // verde
              "Tests Failed": "FF0000"  // vermelho
            };
            let labelToAdd, labelToRemove;
            if (testResult === 'passed') {
              labelToAdd = "Tests Passed";
              labelToRemove = "Tests Failed";
            } else {
              labelToAdd = "Tests Failed";
              labelToRemove = "Tests Passed";
            }
            async function ensureLabel(label) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelConfigs[label]
                  });
                } else {
                  throw error;
                }
              }
            }
            await ensureLabel(labelToAdd);
            // Se houver labels para adicionar, aplica-as (verifica se o array não está vazio)
            if ([labelToAdd].length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pull_number,
                labels: [ labelToAdd ]
              });
            }
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number
            });
            const currentLabelNames = currentLabels.map(label => label.name);
            if (currentLabelNames.includes(labelToRemove)) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pull_number,
                name: labelToRemove
              });
            }
            // Se o teste fake falhar, lança um erro para interromper o workflow
            if (testResult === 'failed') {
              throw new Error("Fake tests failed.");
            }

      # Se os testes passaram, solicita automaticamente o revisor "dilneiss"
      - name: Solicitar aprovação automática e atribuição
        if: steps.check_tests.outputs.testResult == 'passed'
        uses: actions/github-script@v6
        with:
          script: |
            const pull_number = context.payload.pull_request.number;
            const pr = context.payload.pull_request;

            // Verifica se já há algum revisor designado
            if (pr.requested_reviewers && pr.requested_reviewers.length > 0) {
              console.log("Já existe um revisor designado. Nenhuma ação tomada.");
              return;
            }

            // Lista de revisores possíveis
            const reviewersList = ["dilneiss", "dilneiconectala", "dilneiconectala"];

            // Obter o autor do PR
            const prAuthor = pr.user.login;

            // Remove o autor da lista de revisores para evitar que ele seja escolhido como revisor
            const filteredReviewers = reviewersList.filter(rev => rev !== prAuthor);

            // Se a lista ficar vazia, não faz nada
            if (filteredReviewers.length === 0) {
              console.log("Não há revisores disponíveis que não sejam o autor do PR.");
              return;
            }

            // Seleciona aleatoriamente um revisor da lista filtrada
            const selectedReviewer = filteredReviewers[Math.floor(Math.random() * filteredReviewers.length)];
            console.log(`Revisor selecionado: ${selectedReviewer}`);

            // Solicita o revisor selecionado
            await github.rest.pulls.requestReviewers({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull_number,
              reviewers: [selectedReviewer]
            });

            // Atribui tanto o revisor selecionado quanto o autor do PR como responsáveis (assignees)
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull_number,
              assignees: [selectedReviewer, prAuthor]
            });
      
      
